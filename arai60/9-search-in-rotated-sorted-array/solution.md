# [Search in rotated sorted array](https://leetcode.com/problems/search-in-rotated-sorted-array)

## Initial trial (FAILED) fail1.py

### 考えたこと

```
[5,  6, <0,  1,  2,  3,  4>]
[3,  4,  5,  6, <0,  1,  2>]
[2,  3,  4,  5,  6, <0,  1>]
```

- 左端から見ていくと， `list[i] > list[i+1]` となるようなiが高々1つある
- そこを境に，リストは2つに分けられる
- まずはその分かれ目を特定し，次に探している値が入っている側のみを探索する

### 反省点

- これを行おうとすると結構大変で，線形探索をせずに1回で場所を特定するのは厳しいのでループ内に移動→上手く行かず

## Upsolve solve1.py

### 考え方

- リストを2分割したとき，**少なくとも片方は必ずソートされている**ことに注目する
- これを使うと以下のようなことが出来る
  - `nums[left] <= nums[mid]` => 左側がソートされている => `nums[left] <= target < nums[mid]` なら左側を見るべき，そうでないなら右側を見るべき
  - `nums[mid] <= nums[right]` => 右側がソートされている => `nums[mid] < target <= nums[right]` なら右側を見るべき，そうでないなら左側を見るべき
- 以上をwhileの中で繰り返せば良い．

### 反省点

- 最初にリストを分割してソートされたリスト2つに分けてから探索しようという考えが良くなかった．
- 正しい解法ではソートされている側の半分を活用して探索範囲を狭めていっており，いわば「ソートされていない部分が存在するという問題を先送りしている」ことによって難しいことを考えずに済んでいる．
- ソートされていない側の半分に気を取られていたが，注目しているのと反対側の性質も考えるということが大事だなと思った．